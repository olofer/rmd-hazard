#
# BASIC TOOLKIT FOR DYN-P VALUE SOLVER ON (T,X) GRID
# FROM TIME-SPACE-INHOMOGENEOUS SDE SPECIFICATIONS (1D).
#

# sdep contains drift-diffusion dynamics specification plus
# value function specifications (source and terminal and hazard).
# The terminal value will be attained just after time t12[2]
# and the solution will be generated by backward induction until t12[1].
# Both the time and the space grids are generated as equidistant
# with nt, nx cells respectively.
# Absorbing boundary condition is implicit.

solve.dynp.value <- function(sdep, nx, x12, nt, t12)
{
  stopifnot(is.list(sdep))
  xbrk <- seq(from = x12[1], to = x12[2], len = nx + 1)
  xmid <- (xbrk[2:(nx + 1)] + xbrk[1:nx]) / 2
  tbrk <- seq(from = t12[1], to = t12[2], len = nt + 1)
  tmid <- (tbrk[2:(nt + 1)] + tbrk[1:nt]) / 2
  U <- array(NA, c(nx, nt))
  dt <- (t12[2] - t12[1]) / nt
  dx <- (x12[2] - x12[1]) / nx
  uw <- sqrt(dt)
  u <- sdep$psi(xmid)  # terminal value initialization
  kk <- nt
  while (kk > 0) {
    uk <- array(NA, nx)
    for (ii in 1:nx) {
      mu.i <- sdep$mu(xmid[ii], tmid[kk])
      sigma.i <- sdep$sigma(xmid[ii], tmid[kk])
      h.i <- sdep$h(xmid[ii], tmid[kk])
      f.i <- sdep$f(xmid[ii], tmid[kk])
      m.i <- exp(mu.i * dt) - 1
      sd.i <- uw * sigma.i
      alpha.lo <- ((xmid - xmid[ii]) - dx/2 - m.i) / sd.i
      alpha.hi <- ((xmid - xmid[ii]) + dx/2 - m.i) / sd.i
      p.ij <- pnorm(alpha.hi) - pnorm(alpha.lo)
      uk[ii] <- dt * f.i + exp(-dt*h.i) * sum(p.ij * u)
    }
    U[, kk] <- uk
    kk <- kk - 1
    u <- uk
  }
  list(
    xbrk = xbrk, xmid = xmid,
    tbrk = tbrk, tmid = tmid,
    U = U
  )
}

# Solve the forward Markov Chain (as discretized by the SDE specification)
# The initial probability vector is p0 (nx elements)
solve.markov.probs <- function(sdep, nx, x12, nt, t12, p0)
{
  stopifnot(is.list(sdep))
  stopifnot(length(p0) == nx)
  xbrk <- seq(from = x12[1], to = x12[2], len = nx + 1)
  xmid <- (xbrk[2:(nx + 1)] + xbrk[1:nx]) / 2
  tbrk <- seq(from = t12[1], to = t12[2], len = nt + 1)
  tmid <- (tbrk[2:(nt + 1)] + tbrk[1:nt]) / 2
  P <- array(NA, c(nx, nt))
  dt <- (t12[2] - t12[1]) / nt
  dx <- (x12[2] - x12[1]) / nx
  uw <- sqrt(dt)
  p <- p0
  kk <- 1
  while (kk <= nt) {
    pk <- array(NA, nx)
    for (ii in 1:nx) {
      mu.j <- sdep$mu(xmid, tmid[kk])
      sigma.j <- sdep$sigma(xmid, tmid[kk])
      h.j <- sdep$h(xmid, tmid[kk])
      m.j <- exp(mu.j * dt) - 1
      sd.j <- uw * sigma.j
      alpha.lo <- ((xmid[ii] - xmid) - dx/2 - m.j) / sd.j
      alpha.hi <- ((xmid[ii] - xmid) + dx/2 - m.j) / sd.j
      p.ji <- pnorm(alpha.hi) - pnorm(alpha.lo)
      p.ji <- p.ji * exp(-dt * h.j)  # hazard term "dissipates" probs.
      pk[ii] <- sum(p.ji * p)
    }
    P[, kk] <- pk
    kk <- kk + 1
    p <- pk
  }
  list(
    xbrk = xbrk, xmid = xmid,
    tbrk = tbrk, tmid = tmid,
    P = P, p0 = p0
  )
}

#
# Backward induction of value function; given an *estimate* of
# the drift-diffusion SDE {mu, sigma} and either estimates
# or known truths for {f, h}, but always the known truth
# for psi. Absorbing boundaries are implied.
#

solve.dynp.value.est <- function(
  sdep,
  mu.val,
  sigma.val,
  f.val = NULL,
  h.val = NULL)
{
  stopifnot(is.list(sdep))
  stopifnot(is.list(mu.val))
  xbrk <- mu.val$xbrk
  xmid <- mu.val$xmid
  tbrk <- mu.val$tbrk
  tmid <- mu.val$tmid
  nx <- length(xmid)
  nt <- length(tmid)
  stopifnot(all(xbrk == sigma.val$xbrk))
  stopifnot(all(tbrk == sigma.val$tbrk))
  use.f.val <- !is.null(f.val)
  if (use.f.val) {
    stopifnot(all(xbrk == f.val$xbrk))
    stopifnot(all(tbrk == f.val$tbrk))
  }
  use.h.val <- !is.null(h.val)
  if (use.h.val) {
    stopifnot(all(xbrk == h.val$xbrk))
    stopifnot(all(tbrk == h.val$tbrk))
  }
  U <- array(NA, c(nx, nt))
  dt <- (max(tbrk) - min(tbrk)) / nt
  dx <- (max(xbrk) - min(xbrk)) / nx
  uw <- sqrt(dt)
  u <- sdep$psi(xmid)  # KNOWN terminal value initialization
  kk <- nt
  while (kk > 0) {
    uk <- array(NA, nx)
    for (ii in 1:nx) {
      mu.i <- mu.val$U[ii, kk]
      sigma.i <- sigma.val$U[ii, kk]
      if (use.h.val) {
        h.i <- h.val$U[ii, kk]
      } else {
        h.i <- sdep$h(xmid[ii], tmid[kk])  # KNOWN TRUTH
      }
      if (use.f.val) {
        f.i <- f.val$U[ii, kk]
      } else {
        f.i <- sdep$f(xmid[ii], tmid[kk])  # KNOWN TRUTH
      }
      m.i <- exp(mu.i * dt) - 1  # zero-order-hold
      sd.i <- uw * sigma.i
      alpha.lo <- ((xmid - xmid[ii]) - dx/2 - m.i) / sd.i
      alpha.hi <- ((xmid - xmid[ii]) + dx/2 - m.i) / sd.i
      p.ij <- pnorm(alpha.hi) - pnorm(alpha.lo)
      uk[ii] <- dt * f.i + exp(-dt*h.i) * sum(p.ij * u)
    }
    U[, kk] <- uk
    kk <- kk - 1
    u <- uk
  }
  list(
    xbrk = xbrk, xmid = xmid,
    tbrk = tbrk, tmid = tmid,
    f.estim = use.f.val, h.estim = use.h.val,
    mu.estim = TRUE, sigma.estim = TRUE,
    U = U
  )
}
